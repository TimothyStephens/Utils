#!/bin/env bash
set -e

# Instructions:
#
# Place this script into the ".git/hooks/" directory in your repository. It must be called "pre-commit" and be
# executable. A Git hook only works in a single repository. You need to copy this hook into every repository you wish to
# use it in manually. Optionally, you can set up a symlink in the ".git/hooks/" directory pointing to the script.
#
# Each time you try to commit something, this script will run to check the content you are committing.
#
# Should you want to bypass the pre-commit hook (though not recommended), you can commit with "git commit --no-verify".
#
# This hook is composed of two parts:
#   (1) Check commited files are < 100 MB - the GitHub push limit
#   (2) Spell checks the content you are committing





#######################################################################
#######################################################################
#### (1) Check commited files are < 100 MB - the GitHub push limit ####
#######################################################################
#######################################################################

# This is a pre-commit hook that ensures attempts to commit files that
# are larger than 100 MB to your _local_ repo fail, with a helpful error
# message.
# 
# This prevents the local repo from getting out of sync with the Github 
# repo. To install
# 1) Change this file to executable: 
#    $ chmod a+x pre-commit
# 2) Move into the .git/hooks directory at the top-level of the repo
#    $ mv pre-commit .git/hooks/
#
# See blog post on https://kiwidamien.github.io/prevent-big-commits
# Based on code from: https://gist.github.com/kiwidamien/a6a909ee196be8795b30431079074d64

limitInMB=100
limit=$(( $limitInMB * 2**20 )) 

empty_tree=$( git hash-object -t tree /dev/null )
if git rev-parse --verify HEAD > /dev/null 2>&1
then
	against=HEAD
else
	against=empty_tree
fi

file_too_large() {
cat <<HEREDOC

	Found $LARGE_FILES_FOUND files with size larger then github's maximum file size of 100 MB. Commit aborted!
	Please run the following commands to remove large files from commit:

HEREDOC

for i in "${LARGE_FILES[@]}"; do
	echo "git rm --cached $i"
done

cat <<HEREDOC

	If you want to exclude these files from subsequent commits. Run the following
	commands to add these files to your repo .gitignore file.

HEREDOC

for i in "${LARGE_FILES[@]}"; do
        echo "echo \"$i\" >> .gitignore"
done
echo ""
}

# Check each file in commit and track which are >100MB
LARGE_FILES_FOUND=0
unset LARGE_FILES
for file in $( git diff-index --cached --diff-filter=d --name-only $against ); do
	file_size=$( ls -la $file | awk '{ print $5 }')
	if [ "$file_size" -gt  "$limit" ]; then
		echo -e "\tFile $file is $(( $file_size / 2**20 )) MB, which is larger than our configured limit of $limitInMB MB"
		LARGE_FILES_FOUND=$(( $LARGE_FILES_FOUND + 1 ))
		LARGE_FILES[$LARGE_FILES_FOUND]=$file
	fi
done

# Print warning and list of files (and commands to remove) which are >100MB
if [ $LARGE_FILES_FOUND -gt 0 ]; then
	file_too_large
	exit 1
fi





#########################################################
#########################################################
#### (2) Spell checks the content you are committing ####
#########################################################
#########################################################

# The following is a text file that represents your custom dictionary; edit as necessary. Add words to it that you wish
# to ignore for the spell check.
dict=~/.git-spell-check
if [ ! -f $dict ]; then
    touch ~/.git-spell-check
    dict=~/.git-spell-check
    printf "%s\n" "Custom dictionary not found. Created ~/.git-spell-check..."
fi


# The following is a temporary dictionary (a binary file) created from the dict text file. It is deleted after the
# script finishes.
if [ -z "$TMPDIR" ]; then export TMPDIR="/tmp"; fi
temp_dict=$(mktemp --tmpdir="$TMPDIR" docs-dictionary-XXXXXX)

# Language of your doc. When using a non-English language, make sure you have the appropriate aspell libraries
# installed: "yum search aspell". For example, to spell check in Slovak, you must have the aspell-sk package installed.
lang=en

# Define an extension for any additional dictionaries (containing words that are ignored during the spell check) that
# are kept locally in your repository. These dictionaries will be loaded on top of the existing global dictionary (by
# default ~/.git-spell-check).
extension=pws

# Clean up if script is interrupted or terminated.
trap "cleanup" SIGINT SIGTERM 

# Prepares the dictionary from scratch in case new words were added since last time.
function prepare_dictionary() {

    local_dict=$(find . -name *.$extension -exec ls {} \;)
    if [ -z "$local_dict" ]; then
        sort -u $temp_dict -o $temp_dict
        aspell --lang="$lang" create master "$temp_dict" < "$dict"
    else
        temp_file=$(mktemp temp_file-XXXXXX)
        for file in $local_dict; do
            cat $file >> $temp_file
        done
        cat $dict >> $temp_file
        sort -u $temp_file -o $temp_file
        aspell --lang="$lang" create master "$temp_dict" < "$temp_file"
        /bin/rm -f "$temp_file"
    fi

}

# Removes the temporary dictionary.
function cleanup() {

    /bin/rm -f "$temp_dict"

}

# Spell checks content you're about to commit. Writes out words that are misspelled or exits with 0 (i.e. continues with
# commit).
function spell_check() {

    words=$(git diff --cached | grep -e "^+[^+]" | aspell --mode=sgml list --add-sgml-skip={ulink,code,literal,firstname,parameter,option,package,replaceable,programlisting,userinput,screen,filename,command,computeroutput,abbrev,accel,orgname,surname,foreignphrase,acronym,hardware,keycap,systemitem,application} --lang="$lang" --extra-dicts="$temp_dict" | sort -u)
    if [ ! "$words" ]; then
        printf "%s\n" "No typos found. Proceeding with commit..."
        cleanup; exit 0
    fi
    printf "%s\n" "Spell check failed on the following words:
-------------------------------------------------"
    echo $words
    for word in $words; do
        grep --color=always --exclude-dir={.git,tmp} -HIrone "\<$word\>" $(git diff --cached --name-only --diff-filter=ACMRTUXB) | awk -F ":" '{print "File: " $1 "\ton line: " $2 "\tTypo: " $3}'
        printf "%s\n" "-------------------"
    done

}

# Adds all, some, or none of the misspelled words to the custom dictionary.
function add_words_to_dict() {

    printf "%s\n" "
Add any of the misspelled words into your custom dictionary?
  * a[ll]     (add all words into dict, continue with commit)
  * s[ome]    (add some words into dict, fix others, no commit)
  * i[gnore]  (add some words into dict, ignore rest, continue with commit)
  * n[one]    (no commit)
"

    while true; do
        exec < /dev/tty # Simply reading user input does not work because Git hooks have stdin detached.
        read answer
        shopt -s nocasematch
        case "$answer" in
            a|all)
                add_all
                cleanup; exit 0
                ;;
            s|some)
                add_some
                printf "%s\n" "Please fix remaining typos, use \"git add\" to add fixed files, and commit."
                cleanup; exit 1
                ;;
            i|ignore)
                add_some
                cleanup; exit 0
                ;;
            n|none)
                add_none
                cleanup; exit 1
                ;;
            *) 
                printf "%s\n" "Incorrect answer. Try again."
                continue
        esac
        shopt -u nocasematch
    done

}

# Adds all words to the custom dictionary and continues with the commit.
function add_all() {

    for word in $words; do
        echo $word >> "$dict"
    done

}

# Adds some (selected by user) of the words to the dictinary.
function add_some() {

    for word in $words; do
        printf "%s\n" "Do you want to add the following word to your custom dictionary: $word  (y[es] or n[o])"
        while true; do
            exec < /dev/tty
            read answer
            shopt -s nocasematch
            case "$answer" in
                y|yes)
                    echo $word >> "$dict"
                    printf "%s\n" "\"$word\" added to your custom dictionary."
                    break ;;
                n|no)
                    break ;;
                *) 
                    printf "%s\n" "Incorrect answer. Try again."
                    continue
            esac
            shopt -u nocasematch
        done
    done

}

# Adds none of the words.
function add_none() {

    printf "%s\n" "No words were added to your custom dictionary."
    printf "%s\n" "Please fix remaining typos, use \"git add\" to add fixed files, and commit."

}


prepare_dictionary
spell_check
add_words_to_dict


